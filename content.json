{"meta":{"title":"固高视觉团队博客","subtitle":"","description":"","author":"GtVision","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2020-05-15T09:50:30.000Z","updated":"2020-05-15T09:51:35.508Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mvc-mvp-mvvm架构演进","slug":"mvc-mvp-mvvm","date":"2020-05-16T06:00:10.000Z","updated":"2020-05-16T06:24:28.247Z","comments":true,"path":"2020/05/16/mvc-mvp-mvvm/","link":"","permalink":"http://yoursite.com/2020/05/16/mvc-mvp-mvvm/","excerpt":"","text":"PDF文档如下：","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"}],"author":"lizhan"},{"title":"Function实现","slug":"functor","date":"2020-05-15T09:54:29.000Z","updated":"2020-05-16T06:07:43.364Z","comments":true,"path":"2020/05/15/functor/","link":"","permalink":"http://yoursite.com/2020/05/15/functor/","excerpt":"","text":"一、Function解决什么问题1.1 范式对象范式的两个基本观念： 程序是由对象组成的； 对象之间互相发送消息，协作完成任务； 必须知道对象的类型，才能向对象发消息。 导致，面向对象变成了面向类，面向类变成了构造类树。面向对象能解决 is-a 的问题，而很难处理 like-a 的情况。 继承： 123456789101112131415class Bird&#123;public: virtual void fly() = 0; virtual void run() = 0; virtual void swim() = 0;&#125;class Penguin ： public Bird&#123;&#125;class Sparrow ： public Bird&#123;&#125; 另一种范式： 123456void fly();void run();void swim();Penguin(&amp;run, &amp;swim);Sparrow(&amp;fly, &amp;run); 1.2 考虑重新实现一个消息映射采用继承的方式去管理鼠标事件： 123456class MouseEvent : class Event&#123;public: virtual bool mouseClicked(MouseEvent* e); virtual bool mouseDoubleClicked(MouseEvent* e);&#125; 一个 Button 的实现： 12345678910class Button : public MouseEvent&#123;public: Button() &#123; // add self to event dispather &#125; bool mouseClicked(MouseEvent* e); bool mouseDoubleClicked(MouseEvent* e);&#125; 12345class EventDispather&#123;public: bool process(Obj* obj, int msg);&#125; 我们称上述这种方式为静态消息机制，这种机制下，我们必须知道 Button 是什么东西，才能向 Button 派发事件。 如果对象不关心派发的过程，只被动接受事件，如果自己处理不了，就返回 无法理解，继续向下一个对象派发，这样就解决了知道才能派发的困境。 那我们称这种方式为动态消息机制，可以通过内存派发，可以通过进程通讯派发…… 123456789101112131415161718192021222324typedef Function&lt;bool (Event*)&gt; MouseHandler;typedef List&lt;MouseHandler&gt; MouseHandlerList;typedef Map&lt;int, MouseHandlerList&gt; EventMap;extern EventMap map_;bool processEvent(int msg, Event* e)&#123; bool accept = false; Map::Iterator iter = map_.find(msg); if (iter != map_.end()) &#123; for (MouseHandler::Iterator it = *iter-&gt;begin(); !accept &amp;&amp; it != *iter.End(); ++it) &#123; accept = (*it)(e); &#125; &#125;&#125;void appendMouseHandler(int msg, MouseHandler handler)&#123; map_[msg].push_back(handler);&#125; 1234567891011121314class Button&#123;public: Button() &#123; appendMouseHandler(BUTTON_CLICK, MouseHandler(this, &amp;Button::mouseClicked)); appendMouseHandler(BUTTON_DCLICK, MouseHandler(this, &amp;Button::mouseDoubleClicked)); &#125; bool mouseClicked(Event* e); bool mouseDoubleClicked(Event* e);&#125; 这种类似回调函数的机制，过去要求函数必须为静态的，或者全局的，但是我们这种使用方式，要求能够将对象的成员函数暴露出去，被别人所调用。这种机制就是 c++11 之后提供的 Function。 二、Fuction具体实现c++98 里面没有提供 Function，需要自行实现。 下面是 Function 的几种使用场景： 12345678int intfun0() // c函数&#123; return 1;&#125;Function&lt;int ()&gt; f1(&amp;intfun0);Function&lt;int ()&gt; f1_(intfun0);f1();f1_(); 123456789struct Test&#123; int intmem0() // 成员函数 &#123; return 3; &#125;&#125; test;Function&lt;int ()&gt; f3(&amp;test, &amp;Test::intmem0); 第一步，实现包裹 c 函数。 12345678910template&lt;typename R, typename T&gt;class Function0&#123;public: Function0(const T&amp; func) : func_(func) &#123;&#125; R Invoke() &#123; return func_(); &#125;private: T func_;&#125; 第二步，实现包裹成员函数。 1234567891011template&lt;typename R, typename P, typename T&gt;class MemberFunction0&#123;public: MemberFunction0(P obj, R(T::* mem_func)()) : obj_(obj), mem_func_(mem_func) &#123;&#125; R Invoke() &#123; return (obj_-&gt;*mem_func_)(); &#125;private: P obj_; R(T::* mem_func_)();&#125;; 第三步，统一管理。这就要求 Function0 和 MemberFunction0 是同一种东西，必须继承自同一个父类。 1234567template&lt;typename R&gt;class FunctionBase0&#123;public: virtual R Invoke() = 0; virtual ~FunctionBase0() &#123;&#125;&#125;; 1234567891011121314151617template &lt;typename R&gt;class Function&lt;R()&gt;&#123;public: template&lt;typename T&gt; Function(T func) : func_(new Function0&lt;R, T&gt;(func)) &#123;&#125; template&lt;typename P, typename T&gt; Function(P obj, R(T::* mem_func)()) : func_(new MemberFunction0&lt;R, P, T&gt;(obj, mem_func)) &#123;&#125; ~Function() &#123; delete func_; &#125; R operator()() &#123; return func_-&gt;Invoke(); &#125;private: FunctionBase0&lt;R&gt;* func_;&#125;; 第四步，Function 此时没有默认的构造函数，也就是说 Function 只能传递参数才能用，无法实现默认为空函数的情况。 123456789template&lt;typename R&gt;class EmptyFunction0 : public FunctionBase0&lt;R&gt;&#123;public: EmptyFunction0() &#123;&#125; R Invoke() &#123; return R(); &#125;&#125;;Function() : func_(new EmptyFunction0&lt;R&gt;()) &#123;&#125; 至此，就实现了所有 0 个参数的函数情况，因为c++98中不支持变参模板，我们不得不手动实现 1 个参数的函数、2 个参数的函数…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859template&lt;typename R, typename T0&gt;class FunctionBase1&#123;public: virtual R Invoke(T0) = 0; virtual ~FunctionBase1() &#123;&#125;&#125;;template &lt;typename R, typename T0, typename T&gt;class Function1 : public FunctionBase1&lt;R, T0&gt;&#123;public: Function1(const T&amp; func) : func_(func) &#123;&#125; R Invoke(T0 v0) &#123; return func_(v0); &#125;private: T func_;&#125;;template&lt;typename R, typename T0&gt;class EmptyFunction1 : public FunctionBase1&lt;R, T0&gt;&#123;public: EmptyFunction1() &#123;&#125; R Invoke(T0 v0) &#123; return R(); &#125;&#125;;template&lt;typename R, typename P, typename T0, typename T&gt;class MemberFunction1 : public FunctionBase1&lt;R, T0&gt;&#123;public: MemberFunction1(P obj, R(T::* mem_func)(T0)) : obj_(obj), mem_func_(mem_func) &#123;&#125; R Invoke(T0 v0) &#123; return (obj_-&gt;*mem_func_)(v0); &#125; private: P obj_; R(T::* mem_func_)(T0);&#125;;template &lt;typename R, typename T0&gt;class Function&lt;R(T0)&gt;&#123;public: Function() : func_(new EmptyFunction1&lt;R, T0&gt;()) &#123;&#125; template&lt;typename T&gt; Function(T func) : func_(new Function1&lt;R, T0, T&gt;(func)) &#123;&#125; template&lt;typename P, typename T&gt; Function(P obj, R(T::* mem_func)(T0)) : func_(new MemberFunction1&lt;R, P, T0, T&gt;(obj, mem_func)) &#123;&#125; ~Function() &#123; delete func_; &#125; R operator()(T0 v0) &#123; return func_-&gt;Invoke(v0); &#125;private: FunctionBase1&lt;R, T0&gt;* func_;&#125;;","categories":[],"tags":[{"name":"template","slug":"template","permalink":"http://yoursite.com/tags/template/"},{"name":"编程技巧","slug":"编程技巧","permalink":"http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"}],"author":"lizhan"},{"title":"Hello World","slug":"hello-world","date":"2020-05-15T09:32:31.330Z","updated":"2020-05-15T09:32:31.330Z","comments":true,"path":"2020/05/15/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"},{"name":"template","slug":"template","permalink":"http://yoursite.com/tags/template/"},{"name":"编程技巧","slug":"编程技巧","permalink":"http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"}]}