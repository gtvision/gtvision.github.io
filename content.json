{"meta":{"title":"固高视觉团队博客","subtitle":"","description":"","author":"GtVision","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2020-05-15T09:50:30.000Z","updated":"2020-05-15T09:51:35.508Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"迭代器和萃取","slug":"Iterator&traits","date":"2020-06-19T06:00:10.000Z","updated":"2020-06-19T09:48:18.279Z","comments":true,"path":"2020/06/19/Iterator&traits/","link":"","permalink":"http://yoursite.com/2020/06/19/Iterator&traits/","excerpt":"","text":"通过迭代器将算法与数据结构（容器）分开 一个简单的迭代器1234567template&lt;class InputIterator, class T&gt;InputIterator find(InputIterator first, InputIterator end , const T&amp; value)&#123; while(first != last &amp;&amp; *first!=value) ++first; return first;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243template&lt;typename T&gt;class List&#123; void insert_front(T value); void insert_end(T value); void display(std::ostream &amp;os = std::cout) const;private: ListItem&lt;T&gt;* _end; ListItem&lt;T&gt;* _front; long _size;&#125;template&lt;typename T&gt;class ListItem&#123;public: T value() const &#123;return _value;&#125; ListItem* next() const &#123;return _next;&#125;private: T _value; ListItem* _next;&#125;template&lt;class Item&gt;struct ListIter&#123; Item* ptr; ListIter(Iter* p = 0):ptr(p)&#123;&#125; Item&amp; operator*() const &#123;return *ptr;&#125; Item* operator-&gt;() const &#123;return ptr;&#125; ListIter operator++() &#123;ptr = ptr-&gt;next(); return *this;&#125; ListIter operator++(int) &#123; ListIter temp = *this; ++*this; return temp; &#125; bool operator==(const ListIter&amp; i) const &#123;return ptr == i.ptr;&#125; bool operator!=(const ListIter&amp; i) const &#123;return ptr != i.ptr;&#125;&#125; 使用迭代器 12345678910template&lt;typename T&gt;bool operator!=(const ListItem&lt;T&gt;&amp; item, T n)&#123; return item.value() != n;&#125;List&lt;int&gt; mylist;ListIter&lt;ListItem&lt;int&gt;&gt; begin(mylist.front());ListIter&lt;ListItem&lt;int&gt;&gt; end;find(begin, end, 10); 萃取获取迭代器存取的数据类型，例如排序算法需要交换两个迭代器指向的值。 1234567891011template&lt;class I, class T&gt;void swap_impl(I iter1, I iter2, T t)&#123; T tmp; //...&#125;template&lt;class I&gt;void swap(I iter1, I iter2)&#123; swap_impl(iter1, iter2, *iter1);&#125; 缺点：当类型需要用于函数返回值时上述方式将失效 12345678910template&lt;class T&gt;struct MyIter&#123; typedef T value_type; T* ptr; MyIter(T* p=0) : ptr(p)&#123;&#125; T&amp; operator*() const &#123;return *ptr;&#125;&#125;template &lt;class I&gt;typename I::value_type func(I iter)&#123;return *iter;&#125; 缺陷：原生指针非迭代器，但应该可作为迭代器使用 引入萃取 12345678910111213141516171819template&lt;class I&gt;struct iterator_traits&#123; typedef typename I::value_type value_type;&#125;template&lt;class I&gt;typename iterator_traits&lt;I&gt;::value_type func(I iter)&#123;return *iter;&#125;template&lt;class T&gt;struct iterator_traits&lt;T*&gt;&#123; typedef T value_type;&#125;template&lt;class T&gt;struct iterator_traits&lt;const T*&gt;&#123; typedef T value_type;&#125; 常用迭代器的型别123456789template&lt;class I&gt;struct iterator_traits&#123; typedef typename I::iterator_category iterator_category; typedef typename I::value_type value_type; typedef typename I::difference_type difference_type; // 迭代器之间的距离 typedef typename I::pointer pointer; typedef typename I::referance referance;&#125; 关于iterator_category表示迭代器类型, 针对不同迭代器，算法对迭代器的操作不同，例如将某个迭代器前移–advanced() 常见迭代器类型 输入迭代器(Input Iterator) 输出迭代器(Output Iterator) 前向迭代器(Farward Iterator) 双向迭代器(Bidirectional Iterator) 随机读取迭代器(Random Access Iterator) 12345678910111213141516171819202122232425262728template&lt;class Iter, class step&gt;void advance_II(Iter&amp; i, step n)&#123; while(n--) ++i;&#125;template&lt;class Iter, class step&gt;void advance_BI(Iter&amp; i, step n)&#123; if(n &gt;= 0) while(n--) ++i; else while(n++) --i;&#125;template&lt;class Iter, class step&gt;void advance_RAI(Iter&amp; i, step n)&#123; i += n.;&#125;template&lt;class Iter, class step&gt;void advance(Iter&amp; i, step n)&#123; if(is_II) advance_II(i, n); else if(is_BI) advance_BI(i, n); else advance_RAI(i, n);&#125; 定义五个类用于表示迭代器类型，通过重载机制实现不同操作 12345struct input_iterator_tag&#123;&#125;;struct output_iterator_tag&#123;&#125;;struct forward_iterator_tag : public input_iterator_tag&#123;&#125;;struct bidirectional_iterator_tag : public forward_iterator_tag&#123;&#125;;struct random_access_iterator_tag : public Bidirectional_iterator_tag&#123;&#125;; 123456789101112131415161718192021template&lt;class Iter, class step&gt;void __advance(Iter&amp; i, step n, input_iterator_tag)&#123; ...&#125;template&lt;class Iter, class step&gt;void __advance(Iter&amp; i, step n, bidirectional_iterator_tag)&#123; ...&#125;template&lt;class Iter, class step&gt;void __advance(Iter&amp; i, step n, random_access_iterator_tag)&#123; ...&#125;template&lt;class Iter, class step&gt;void advance(Iter&amp; i, step n)&#123; advance(i, n, iterator_traits&lt;iter&gt;::iterator_category());&#125;","categories":[],"tags":[{"name":"template","slug":"template","permalink":"http://yoursite.com/tags/template/"}],"author":"zhangqilong"},{"title":"通讯库实现","slug":"gtcomm","date":"2020-05-19T11:54:30.000Z","updated":"2020-05-19T11:58:08.256Z","comments":true,"path":"2020/05/19/gtcomm/","link":"","permalink":"http://yoursite.com/2020/05/19/gtcomm/","excerpt":"","text":"PDF 文档如下：","categories":[],"tags":[{"name":"通讯","slug":"通讯","permalink":"http://yoursite.com/tags/%E9%80%9A%E8%AE%AF/"},{"name":"TCP","slug":"TCP","permalink":"http://yoursite.com/tags/TCP/"}],"author":"maoyunhai"},{"title":"mvc-mvp-mvvm架构演进","slug":"mvc-mvp-mvvm","date":"2020-05-16T06:00:10.000Z","updated":"2020-05-19T11:46:16.690Z","comments":true,"path":"2020/05/16/mvc-mvp-mvvm/","link":"","permalink":"http://yoursite.com/2020/05/16/mvc-mvp-mvvm/","excerpt":"","text":"PDF文档如下：","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"}],"author":"lizhan"},{"title":"Function实现","slug":"functor","date":"2020-05-15T09:54:29.000Z","updated":"2020-05-16T06:07:43.364Z","comments":true,"path":"2020/05/15/functor/","link":"","permalink":"http://yoursite.com/2020/05/15/functor/","excerpt":"","text":"一、Function解决什么问题1.1 范式对象范式的两个基本观念： 程序是由对象组成的； 对象之间互相发送消息，协作完成任务； 必须知道对象的类型，才能向对象发消息。 导致，面向对象变成了面向类，面向类变成了构造类树。面向对象能解决 is-a 的问题，而很难处理 like-a 的情况。 继承： 123456789101112131415class Bird&#123;public: virtual void fly() = 0; virtual void run() = 0; virtual void swim() = 0;&#125;class Penguin ： public Bird&#123;&#125;class Sparrow ： public Bird&#123;&#125; 另一种范式： 123456void fly();void run();void swim();Penguin(&amp;run, &amp;swim);Sparrow(&amp;fly, &amp;run); 1.2 考虑重新实现一个消息映射采用继承的方式去管理鼠标事件： 123456class MouseEvent : class Event&#123;public: virtual bool mouseClicked(MouseEvent* e); virtual bool mouseDoubleClicked(MouseEvent* e);&#125; 一个 Button 的实现： 12345678910class Button : public MouseEvent&#123;public: Button() &#123; // add self to event dispather &#125; bool mouseClicked(MouseEvent* e); bool mouseDoubleClicked(MouseEvent* e);&#125; 12345class EventDispather&#123;public: bool process(Obj* obj, int msg);&#125; 我们称上述这种方式为静态消息机制，这种机制下，我们必须知道 Button 是什么东西，才能向 Button 派发事件。 如果对象不关心派发的过程，只被动接受事件，如果自己处理不了，就返回 无法理解，继续向下一个对象派发，这样就解决了知道才能派发的困境。 那我们称这种方式为动态消息机制，可以通过内存派发，可以通过进程通讯派发…… 123456789101112131415161718192021222324typedef Function&lt;bool (Event*)&gt; MouseHandler;typedef List&lt;MouseHandler&gt; MouseHandlerList;typedef Map&lt;int, MouseHandlerList&gt; EventMap;extern EventMap map_;bool processEvent(int msg, Event* e)&#123; bool accept = false; Map::Iterator iter = map_.find(msg); if (iter != map_.end()) &#123; for (MouseHandler::Iterator it = *iter-&gt;begin(); !accept &amp;&amp; it != *iter.End(); ++it) &#123; accept = (*it)(e); &#125; &#125;&#125;void appendMouseHandler(int msg, MouseHandler handler)&#123; map_[msg].push_back(handler);&#125; 1234567891011121314class Button&#123;public: Button() &#123; appendMouseHandler(BUTTON_CLICK, MouseHandler(this, &amp;Button::mouseClicked)); appendMouseHandler(BUTTON_DCLICK, MouseHandler(this, &amp;Button::mouseDoubleClicked)); &#125; bool mouseClicked(Event* e); bool mouseDoubleClicked(Event* e);&#125; 这种类似回调函数的机制，过去要求函数必须为静态的，或者全局的，但是我们这种使用方式，要求能够将对象的成员函数暴露出去，被别人所调用。这种机制就是 c++11 之后提供的 Function。 二、Fuction具体实现c++98 里面没有提供 Function，需要自行实现。 下面是 Function 的几种使用场景： 12345678int intfun0() // c函数&#123; return 1;&#125;Function&lt;int ()&gt; f1(&amp;intfun0);Function&lt;int ()&gt; f1_(intfun0);f1();f1_(); 123456789struct Test&#123; int intmem0() // 成员函数 &#123; return 3; &#125;&#125; test;Function&lt;int ()&gt; f3(&amp;test, &amp;Test::intmem0); 第一步，实现包裹 c 函数。 12345678910template&lt;typename R, typename T&gt;class Function0&#123;public: Function0(const T&amp; func) : func_(func) &#123;&#125; R Invoke() &#123; return func_(); &#125;private: T func_;&#125; 第二步，实现包裹成员函数。 1234567891011template&lt;typename R, typename P, typename T&gt;class MemberFunction0&#123;public: MemberFunction0(P obj, R(T::* mem_func)()) : obj_(obj), mem_func_(mem_func) &#123;&#125; R Invoke() &#123; return (obj_-&gt;*mem_func_)(); &#125;private: P obj_; R(T::* mem_func_)();&#125;; 第三步，统一管理。这就要求 Function0 和 MemberFunction0 是同一种东西，必须继承自同一个父类。 1234567template&lt;typename R&gt;class FunctionBase0&#123;public: virtual R Invoke() = 0; virtual ~FunctionBase0() &#123;&#125;&#125;; 1234567891011121314151617template &lt;typename R&gt;class Function&lt;R()&gt;&#123;public: template&lt;typename T&gt; Function(T func) : func_(new Function0&lt;R, T&gt;(func)) &#123;&#125; template&lt;typename P, typename T&gt; Function(P obj, R(T::* mem_func)()) : func_(new MemberFunction0&lt;R, P, T&gt;(obj, mem_func)) &#123;&#125; ~Function() &#123; delete func_; &#125; R operator()() &#123; return func_-&gt;Invoke(); &#125;private: FunctionBase0&lt;R&gt;* func_;&#125;; 第四步，Function 此时没有默认的构造函数，也就是说 Function 只能传递参数才能用，无法实现默认为空函数的情况。 123456789template&lt;typename R&gt;class EmptyFunction0 : public FunctionBase0&lt;R&gt;&#123;public: EmptyFunction0() &#123;&#125; R Invoke() &#123; return R(); &#125;&#125;;Function() : func_(new EmptyFunction0&lt;R&gt;()) &#123;&#125; 至此，就实现了所有 0 个参数的函数情况，因为c++98中不支持变参模板，我们不得不手动实现 1 个参数的函数、2 个参数的函数…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859template&lt;typename R, typename T0&gt;class FunctionBase1&#123;public: virtual R Invoke(T0) = 0; virtual ~FunctionBase1() &#123;&#125;&#125;;template &lt;typename R, typename T0, typename T&gt;class Function1 : public FunctionBase1&lt;R, T0&gt;&#123;public: Function1(const T&amp; func) : func_(func) &#123;&#125; R Invoke(T0 v0) &#123; return func_(v0); &#125;private: T func_;&#125;;template&lt;typename R, typename T0&gt;class EmptyFunction1 : public FunctionBase1&lt;R, T0&gt;&#123;public: EmptyFunction1() &#123;&#125; R Invoke(T0 v0) &#123; return R(); &#125;&#125;;template&lt;typename R, typename P, typename T0, typename T&gt;class MemberFunction1 : public FunctionBase1&lt;R, T0&gt;&#123;public: MemberFunction1(P obj, R(T::* mem_func)(T0)) : obj_(obj), mem_func_(mem_func) &#123;&#125; R Invoke(T0 v0) &#123; return (obj_-&gt;*mem_func_)(v0); &#125; private: P obj_; R(T::* mem_func_)(T0);&#125;;template &lt;typename R, typename T0&gt;class Function&lt;R(T0)&gt;&#123;public: Function() : func_(new EmptyFunction1&lt;R, T0&gt;()) &#123;&#125; template&lt;typename T&gt; Function(T func) : func_(new Function1&lt;R, T0, T&gt;(func)) &#123;&#125; template&lt;typename P, typename T&gt; Function(P obj, R(T::* mem_func)(T0)) : func_(new MemberFunction1&lt;R, P, T0, T&gt;(obj, mem_func)) &#123;&#125; ~Function() &#123; delete func_; &#125; R operator()(T0 v0) &#123; return func_-&gt;Invoke(v0); &#125;private: FunctionBase1&lt;R, T0&gt;* func_;&#125;;","categories":[],"tags":[{"name":"template","slug":"template","permalink":"http://yoursite.com/tags/template/"},{"name":"编程技巧","slug":"编程技巧","permalink":"http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"}],"author":"lizhan"},{"title":"Function实现","slug":"pid控制","date":"2020-05-15T09:54:29.000Z","updated":"2020-06-19T09:52:32.961Z","comments":true,"path":"2020/05/15/pid控制/","link":"","permalink":"http://yoursite.com/2020/05/15/pid%E6%8E%A7%E5%88%B6/","excerpt":"","text":"自动控制的场景 自动扶梯 定速巡航 烧水 自然界平衡 控制的手段反馈: 通过误差去补偿控制信号 控制的目的稳: 系统最终趋于稳定 快: 对信号和负载变化的快速响应 准: 稳态时的结果和目标一致或误差小 PIDP: Proportional 比例 I: Integral 积分 D: Derivative 微分 P的作用成比例地反映控制系统的偏差信号e(t)，偏差一旦产生，控制器立即产生控制作用，以减小偏差 当仅有比例控制时系统输出存在稳态误差（Steady-state error） 仅用P控制器,过大的比例系数不仅会使系统的超调量增大，而且会使系统稳定裕度变小，甚至不稳定 I的作用积分控制器的输出与输入误差信号的积分成正比关系。 主要用于消除稳态误差，提高系统的无差度 积分控制器的加入会影响系统的稳定性,不合理的积分系数会使系统无法达到稳态 有时会对积分限幅,防止其输出过大 D的作用微分控制器的输出与输入误差信号的微分（即误差的变化率）成正比关系。 微分反映偏差信号的变化趋势，并能在偏差信号变得太大之前，在系统中引入一个有效的早期修正信号，从而加快系统的动作速度，减少调节时间。 微分控制器不能单独使用,因为它只有在误差变化时才有输出 同样,不合理的微分系数会使系统震荡,无法达到稳态 PID控制效果 PID实现123456789101112131415161718192021222324252627282930313233struct PID&#123; double e; //e(t) double e1; //e(t)的前一时刻 double e2; //e1的前一个时刻 double u; //u(t） double u1; //u(t)的前一时刻 double Kp, Ki, Kd; //比例、积分、微分系数 double integral; //积分值&#125; pid;double PidPosition(PID&amp; pid,double R,double y1)//位置式pid&#123; pid.e = R - y1;//e=R-y pid.integral += pid.e; pid.u = pid.Kp * pid.e + pid.Ki * pid.integral + pid.Kd*(pid.e - pid.e1); pid.e1 = pid.e; pid.u1 = pid.u; return pid.u;&#125;double PidIncrement(PID&amp; pid,double R,double y1)//增量式PID&#123; pid.e = R - y1; increment = pid.Kp * (pid.e - pid.e1) + pid.Ki * pid.e + pid.Kd * (pid.e - 2 * pid.e1 + pid.e2); pid.u += increment; pid.e2 = pid.e1; pid.e1 = pid.e; return pid.u;&#125; 直流电机的双闭环控制系统 为什么要双闭环 理想控制电流转速图 单闭环控制电流转速图 单闭环控制从结果来说是可以做到转速的无静差调节的,但从图中可以看出,相比于理想控制,调节时间较长是它的主要问题. 双闭环控制在各阶段的表现 双闭环控制电流转速图 特点:启动过程中,电流快速到达上限,保持最大转矩到达速度超调点,最后回稳 0~t0: 速度环饱和,速度调节器输出保持最大值 t0~t1:速度环持续饱和,电流环逐渐达到饱和 t1~t2:速度环持续饱和,电流环退饱和达到稳态 t2~t3:速度环退饱和,电流环跟随速度环的输出 t3~t4:速度环逐渐达到稳态 双闭环的优势 起动和停车更加迅速 对抗负载扰动和电网扰动的响应更迅速","categories":[],"tags":[{"name":"控制","slug":"控制","permalink":"http://yoursite.com/tags/%E6%8E%A7%E5%88%B6/"}],"author":"lizhan"},{"title":"Hello World","slug":"hello-world","date":"2020-05-15T09:32:31.330Z","updated":"2020-05-19T12:05:37.217Z","comments":true,"path":"2020/05/15/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/15/hello-world/","excerpt":"","text":"技术分享的好处【主要目标】提升分享者的交流沟通能力【次要目标】开拓聆听者的视野 如何做技术分享 时间：初始每周一次，定为周四或周五下午，大约一个多小时 内容：前期以技术为主，比如技术选型、技术优劣分析；后期各个方向均可 产出物：最好以 ppt 或者格式明晰的 markdown，pdf 作为展示载体 第一次分享 —— 《所谓软件工程》1. 写清晰的代码简单来说，分支尽量不要超过两层，并且捕获所有的边界条件。同理 for 或者 while 循环也是一样的。 1234567891011// bad if(condition0)&#123; if(condition1) &#123; if(condition2) &#123; …… &#125; &#125;&#125; 这种嵌套太多层的代码，难以一眼看出 if 逻辑的流向，难以调试。改写方法有两种：一种是把内层过多的判断语句提出来作为一个函数；另一种是令异常情况提早返回。 1234567891011121314151617181920212223242526272829303132333435// 提取函数if(condition0)&#123; if(condition1and2) &#123; &#125;&#125;bool condition1and2()&#123; if(condition1) &#123; if(condition2) &#123; &#125; &#125;&#125;/*----------------------------------------*/// 提早返回if(!condition0)&#123; return;&#125;if(!condition1)&#123; return;&#125;if(condition2)&#123;&#125; 下面是一种“简便”写法，利用 if 没有执行之后向下掉到最终的返回值，这样也会违背程序员的第一直觉。 当然这个例子比较简单，看不出有什么特别不对的，但是如果是比较复杂一些的嵌套起来的，就很容易在修改时发生错误。 1234567891011121314151617181920212223242526// goodif(condition0)&#123; if(condition1) &#123; return true； &#125; else &#123; return false; &#125;&#125;else &#123; return false；&#125;// bad if(condition0)&#123; if(condition1) &#123; return true； &#125;&#125;return false； 2. 写模块化的代码 i&gt; 函数尽量短小 函数要尽量短小，如果超过一屏幕还放不下，就像想想函数是否可以简写。 不用过分在意函数调用时发生的开销，现代编译器能够智能的识别一些小函数，并把它作为内联函数，开销极小。 ii&gt; 使用工具函数 比如转换编码，比如显示一个对话框，比如比较两个数的大小……尽量提取这样的具有共性的工具函数，这样会大大简化函数里的逻辑； iii&gt; 每个函数只做一件事 函数应当只承担一项责任，这样你的代码就像是一个大盒子套着一个个的小盒子，大大简化了逻辑，同时函数名可以充当一部分注释的作用。 1234567// 比如一个文件操作if(fileExists(name))&#123; deleteFile(name);&#125;saveFile(name, data); 如果把所有的功能全部写在一起，只会增大重新学习函数的成本，并且很难一眼定位到 bug 所在位置。 另外有一种情况： 1234567891011121314151617181920212223// badvoid foo() &#123; if (getOS() == \"MacOS\") &#123; a(); &#125; else &#123; b(); &#125; c(); if (getOS() == \"MacOS\") &#123; d(); &#125; else &#123; e(); &#125;&#125; 这个函数会判断当前操作系统，然后可能是为了共用一个函数 c()，把不同操作系统的操作放在了一个函数中。 这样的“复用”是有害的，因为不同操作系统之间的共性并不多，所以导致程序需逻辑不够清晰。改写为： 1234567891011121314// goodvoid fooMacOS() &#123; a(); c(); d();&#125;void fooOther() &#123; b(); c(); e();&#125; iv&gt; 少用全局和成员变量来传递参数 如果你使用了全局或者成员变量来传递参数给函数，那么你的函数就是一个难以自洽的函数，你很难在其他地方使用这样的函数。 函数最好就像一个黑盒子，有输入有输出，这样只要规定好可接受参数，这样的函数就能作为一个 API 独立存在了。 1234567891011121314151617// badclass A &#123; int x; void foo0() &#123; x += 1; print(x); &#125; void foo1() &#123; x -= 1; print(x); &#125; &#125; 如上面这个例子，foo0 和 foo1 这两个函数依赖了成员变量 x，这样这两个函数就失去了模块化的可能性，同时 x 因为可能被其他函数修改，导致结果的不可预测。 【注意】这个并没有绝对。如果为了模块性，而函数又需要返回多个值，结果不得不返回一个结构体指针，那样就反而复杂了。 3. 写可读的代码 i&gt; 不要保留无用的注释代码 我们的上位机中有大量无用的注释，大都是当时觉得未来可能有用吧，结果越积攒越多，代码夹杂大量注释掉的代码，完全不可读。 ii&gt; 不要写无用的注释 注释的目的是要说明：一个是为什么这样写代码，适用于复杂逻辑；另一个是告诉别人函数如何使用。 其他时候不要写太多的注释，好的代码应该使用可读的变量名和函数名来提醒调用者其意义。 iii&gt; 使用有意义、无歧义的变量名 iv&gt; 局部变量不要为了有意义，起了太长的名字 v&gt; 局部变量应该尽量靠近调用他的地方 12345678// badfloat a, b, c, d;int e, f, g;......a = e + c; vi&gt; 不要重用局部变量 我们的 setConfigFile 函数里面就是一个大大的反例，很难调试，每次局部变量都会被覆盖： 123456int nValue;float fValue;nValue = ...;fValue = ...;nValue = ...; vii&gt; 合理换行 换行有很多作用：一个是一行不能写的太长，超出屏幕的宽度，导致滚动麻烦；一个是可以把复杂的表达式写清楚。 12345678910111213// badif((condition1 &amp;&amp; condition2) || (condition3 || condition 4) || (condition5))&#123;&#125;// goodif((condition1 &amp;&amp; condition2) || (condition3 &amp;&amp; condition 4) || (condition5))&#123;&#125; viii&gt; 不要使用奇技淫巧 123456789101112// badif((x = 6 + x) != 7)&#123;&#125;// goodx += 6;if(x != 7)&#123; &#125; ix&gt; 模块化你的代码 4. 写傻瓜式的代码 i&gt; 使用括号来指定优先级 1234567891011// badi++ + ++ i;// good (i++) + (++i);// badindex &lt;&lt; 16 | key;// good(index &lt;&lt; 16) | key; ii&gt; 不要省略 if 的大括号 123456789// badif(condition) thendo();// goodif(condition)&#123; thendo();&#125; 苹果iOS 7.0.6（版本号11B651）修复了 SSL 连接验证的一个 bug。这个 bug 是这样的： c123if ((err &#x3D; SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) !&#x3D; 0) goto fail; goto fail; 因为 if 没有加大括号，结果默认这一句之后都会执行 goto fail。 5. 捕获所有可能情况在我们的代码里经常看到: 123456switch()&#123; case 0: case 1: ...&#125; 1234if(pointer != NULL)&#123; ...&#125; 这样都没有考虑到所有的边界条件，如果switch没有default，如果if没有else，很容易漏掉一些边界条件。甚至还有直接不判断拿到的指针是否为空，结果直接代码崩溃。 6. 如何测试 i&gt; print大法 ii&gt; 单步调试 iii&gt; 二分查找 iv&gt; 查看内存 不管是什么测试，都首先要思考为什么会出现这样的 bug，而不是一再的注释测试运行注释测试运行。 7. 反复重写你的代码不断的分析你的代码，精炼、推敲，使程序简单直观，以至于一眼就能看到它不可能出现问题。 https://hexo.io/docs/one-command-deployment.html)","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"template","slug":"template","permalink":"http://yoursite.com/tags/template/"},{"name":"通讯","slug":"通讯","permalink":"http://yoursite.com/tags/%E9%80%9A%E8%AE%AF/"},{"name":"TCP","slug":"TCP","permalink":"http://yoursite.com/tags/TCP/"},{"name":"架构","slug":"架构","permalink":"http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"},{"name":"编程技巧","slug":"编程技巧","permalink":"http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"},{"name":"控制","slug":"控制","permalink":"http://yoursite.com/tags/%E6%8E%A7%E5%88%B6/"}]}